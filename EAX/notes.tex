\documentclass{elsarticle}

\input{includes/preamble.tex}

\begin{document}
	
\begin{frontmatter}
\title{An Evolutionary Algorithm for the Score-Constrained Strip-Packing Problem}
\author{Asyl L. Hawa}
\author{Rhyd Lewis}
\author{Jonathan M. Thompson}
\address{School of Mathematics, Cardiff University, Senghennydd Road, Cardiff, UK}

\end{frontmatter}

%--------------------------------------------------------------------

\section{Introduction}
\begin{itemize}
	\item Define COP, single strip problem and multi-strip problem (SCSPP)
	\item Vicinal sum constraint
	\item Cite Goulimis, previous Heuristics paper, follow on
	\item Lit review, Lewis TSP method
	\item Formal definitions of SCSPP and subproblem
	\item BPP special case of SCSPP where $\tau = 0$, hence SCSPP NP-hard
	\item Need to decide which items to pack on which strips and how the items should be packed, different orientations, s.t. minimum scoring distance met
	\item Show that sub-problem can be seen as an instance of COP, minimum scoring distance = vicinal sum constraint
	\item Describe rest of paper, AHC single strip for COP, Evolutionary Algorithm and Postopt
	\item Two phase approach, cite vertex colouring paper
	\item Minimum scoring distance $\tau$ approx 70mm in industry
	\item $2^{n-1} n!$ distinct arrangement, combinatorial explosion
	\item COP infinite width, strips given fixed width
	\item Outer score widths ignored
	\item Items that cannot be packed can be run through machine individually but extra time/cost
	\item Grouping problem ODMPG 
\end{itemize}
{\color{myOrange}
	\begin{itemize}[leftmargin=*]
		\item
		\idone{Lit review, Becker \cite{becker2015}, Lewis \cite{lewis2011} (Lewis TSP method), Hawa \cite{hawa2018}, cite Garraffa \cite{garraffa2016}.}
		\idone{MGPs, cite Lewis \cite{lewis2009}, general formula.}
		\idone{Formal definition COP, vicinal sum constraint.}
		\idone{Example instance $\mathcal{M}$ of COP and possible solution $\mathcal{T}$ using constraint value $\tau = 7$.}
		\idone{Description of subproblem, pack from left to right, minimum scoring distance, single strip problem.}
		\idone{Cite Goulimis \cite{goulimis2004}.}
		\idone{$a_i, b_i, w_i, \mathcal{I}, \mathcal{I}', W, H, \tau, |\mathcal{I}| = n$.}
		\idone{$\tau$ = 70mm approx in industry.}
		\idone{$(a_i, b_i)$, $(b_i, a_i)$ orientations (regular and rotated).}
		\idone{Outermost score widths/elements ignored.}
		\idone{Need to decide order and orientation of items on strip.}
		\idone{$2^{n-1} n!$ distinct orderings, combinatorial explosion.}
		\idone{Show that the subproblem is equivalent to the COP, minimum scoring distance = VSC.}
		\idone{COP/subproblem the strips have infinite width, what if finite width?}
		\idone{Formal defintion of SCSPP, multistrip problem.}
		\idone{Need to decide which strip to pack each item, and \emph{how}, i.e. what order and orientation should the items be in.}
		\idone{BPP special case of SCSPP with $\tau = 0$.}
		\idone{Items can be run through machine individually but extra time/cost.}
		\idone{Two phase approach, EA then postopt, Malaguti \cite{malaguti2008}.}
		\idone{Call the two phase process EAX?}
		\idone{Polynomial-time algorithm for COP Becker \cite{becker2010} Hawa \cite{hawa2018}}
		\idone{Describe rest of paper/layout.}
		\idone{TPP/SDCL ordering still feasible, just not optimal, SCSPP ordering may not be feasible.}
	\end{itemize}
}


\section{Notation}
\begin{itemize}
	\item $\tau$ - constraint value (minimum scoring distance)
	\item $\mathcal{I}$ - set of items, $|\mathcal{I}| = n$ 
	\item $H$ - height of items
	\item $i$ - index of each item $i \in \mathcal{I}$
	\item $w_i$ - width of item $i$
	\item $a_i, b_i$ - score widths of each item $i$, $a_i \leq b_i$, $a_i + b_i < w_i$
	\item $(a_i, b_i)$ - regular orientation of item $i$, smaller score width on LHS
	\item $(b_i, a_i)$ - rotated orientation of item $i$, smaller score width on RHS
	\item \textbf{rhs}($i$) + \textbf{lhs}($i+1$) $\geq \tau$ - vicinal sum constraint
	\item $W$ - strip width
	\item $\mathcal{M}$ - instance of the COP, cardinality $n$
	\item $\mathcal{T}$ - feasible solution of instance $\mathcal{M}$ of the COP
	\item $G$ - graph modelling instance $\mathcal{M}$ of the COP
	\item $V$ - vertex set, $|V| = 2n + 2$, includes dominating vertices
	\item $B$ - set of edges between partners, $|B| = n+1$, perfect matching
	\item $p : V \to V$ - bijective function associating each vertex with its partner, $p(v_i) = v_j$
	\item $R$ - set of edges between vertices than meet VSC and are not partners
	\item $m : V \to V$ - bijective function associating each vertex with its match, $m(v_i) = v_j$
	\item $G'$ - spanning subgraph, $G' = (V, B \cup R')$, 2-regular graph
	\item $C_1, C_2,..., C_l$ - components of $G'$
	\item $l$ - number of components of $G'$
	\item $R_1, R_2,...$ - sets produced by BR
	\item $\mathcal{R}^* = \{R_{1}^{*}, R_{2}^{*},...\}$ - collection of sets produced by MBR
	\item $\mathcal{S} = \{S_1, S_2,...,S_k\}$ - feasible solution to the SCSPP
	\item $t$ - theoretical minimum, $t = \ceil*{\sum_{i=1}^{n}w_i / W}$, lower bound for $k$
	\item $k$ - fewest number of strips required to pack all items feasibly
	\item $q$ - solution quality, $q = |\mathcal{S}| / t$
	\item $A(S) = \sum_{i \in S}w_i$ - strip capacity/area, total width of all items on strip $S$
	\item $\mathcal{F}$ - the set of all item combinations that can be feasibly packed onto a single strip, i.e the items' total width does not exceed strip width and there exists an ordering of the items such that the vicinal sum constraint is met between all adjacent items
	\item $\mathcal{S}_X, \mathcal{S}_Y$ - feasible sub-solutions that together make up a full solution
\end{itemize}

\section{AHC}
\begin{itemize}
	\item Condensed version of algorithm from previous paper
	\item Set notation and terms to be used throughout paper
	\item Theorem/Proof polynomial time $O(n^2)$
	\item Alternating Hamiltonian cycle NP-hard generalises Ham cycle problem, but special graph structure means solution can be found in polynomial time
	\item Pseudocode/brief overview of AHC algorithm in steps
	\item Preliminary checks - these were not included in previous paper, speed
	\item Preliminary check
	\item Model instance graphically, graph $G$ has $2n+2$ vertices, including 2 extra dominating vertices (which will be removed at the end) and two edge sets, $B$ and $R$
	\item $B$ = set of edges between vertices that are partners (that make up a pair in the instance $\mathcal{M}$), ``blue'' edges. $R$ - set of edges between vertices that are not partners and whose values add up to $\geq \tau$
	\item Define Alt ham cycle.
	\item Aim - to find set of edges $R' \subseteq R$ that forms an alternating hamiltonian cycle with the edges in $B$
	\item Alt ham cycle NP-hard as it generalises Ham cycle propostion (proof), but structure of these graphs means can solve in polynomial time
	\item MCM - match each vertex with largest possible vertex, create set $R'$. If $|R'| < n+1$, no solution exists, not enough edges to form cycle, end. Else if $|R'| = n+1$, i.e. matching, then $G' = (V, B \cup R')$ is 2-reg graph, consists of cycles $C_1,...,C_l$.
	\item If $l = 1$, then $G'$ is alt ham cycle, solution found, end (remove dom vertices). Else we need to find edges from $R\backslash R'$ that can act as bridges between the components and join them together into a single cycle. 
	\item Use BR to find these edges. List edges in order, go through to find edges that meet specific conditions. Continue until penultimate edge reached. BR produces sets $R_1, R_2,...$
	\item If no sets produced, no solution exists, end. Else if $\exists$ set such that $|R_i| = l$, use connecting procedure to join components together, solution found, end.
	\item Else multiple sets need to be used, run MBR to find two or more sets that overlap correctly. If collection $\mathcal{R}^*$ found, connecting procedure on all sets in collection, solution found, end. Else, no solution exists, end.
	\item Guaranteed to find solution, if one exists, in $O(n^2)$ time.
	\item Condensed version of algorithm from previous paper
	\item Theorem/Proof polynomial time $O(n^2)$
	\item Hamiltonian cycle characteristics, NP-hard, Karp 21 NP-Complete problem (both direct and undirected), complexity
	\item Pseudocode/brief overview of AHC algorithm in steps
	\item Preliminary checks - these were not included in previous paper, speed
	\item MBR types, check that Beckers method is redundant
	\item Add dominating vertices to help produce Ham cycle, remove at end, outer score widths ignored
	\item Theorem MCM guarantee $O(n \lg n)$
\end{itemize}
{\color{myBlue}
	\begin{itemize}[leftmargin=*]
		\item
		\idone{How does this method differ from Becker's?}
		\idone{Exact Polynomial-time algorithm for COP Becker \cite{becker2015} Hawa \cite{hawa2018}.}
		\idone{Model instance graphically, graph $G$ with $V = \{v_1, ...v_{2n}\}$ vertices, one for each value in $\mathcal{M}$ in non-decreasing order.}
		\idone{Preliminary checks using elements, explain, speed.}
		\idone{Cite Lewis \cite{lewis2011} for preliminary checks.}
		\idone{Add two dominating vertices, have value equal to $\tau$, therefore $G$ has $2n+2$ vertices.}
		\idone{Dom vertices will be removed at the end.}
		\idone{degree $2n+1$.}
		\idone{$B$, blue edges between ``partners'' (values that make up a pair in $\mathcal{M}$)}.
		\idone{$|B| = n+1$, perfect matching.}
		\idone{Footnote dom vertices are partners.}
		\idone{Bijective function partners, $p : V \to V$, $p(v_i) = v_j$.}
		\idone{$R$, red edges between vertices whose values add up to $\tau$/meet VSC and are not partners.}
		\idone{Given the bijective function $p:V \to V$ that associates each vertex $v_i \in V$ with its partner $p(v_i)$, we can denote the set of blue edges as $B = \{(v_i, p(v_i)) : v_i \in V\}$.}  
		\idone{Then we have a graph $G = (V, B \cup R)$ (see figure).}
		\idone{Higher-indexed vertices have larger degrees.}
		\idone{Define Ham cycle, formal definition alt Ham cycle.}
		\idone{$R$ = all possible pairings of values.}
		\idone{$B$ cannot be altered, all edges must remain, as each edge represents a pair of values.}
		\idone{Therefore aim is to find set of edges from $R$ that forms alt Ham cycle with $B$.}
		\idone{Ham cycle NP-complete, Karp \cite{karp1972}, alt Ham generalises Ham cycle, Haggkvist \cite{haggkvist1977} proposition, special structure of graphs means can solve in polynomial-time.}
		\idone{MCM - match each vertex with largest possible vertex, create set $R'$.}
		\idone{Cite Mahadev \cite{mahadev1994}.}
		\idone{Explain ``matched'', bijective function.}
		\idone{Can denote $R'$ as $R' = \{(v_i, m(v_i)) : v_i \in V\}$.}
		\idone{Swap of partners.}
		\idone{If $|R'| < n+1$, no solution exists, not enough edges to form cycle, end. Else if $|R'| = n+1$, i.e. matching, then $G' = (V, B \cup R')$ is 2-reg graph, consists of cycles $C_1,...,C_l$.}
		\idone{If $l = 1$, then $G'$ is alt ham cycle, solution found, end.}
		\idone{Else we need to find edges from $R\backslash R'$ that can act as bridges between the components and join them together into a single cycle.}
		\idone{Use BR to find these edges. List edges in order, go through to find edges that meet specific conditions. Continue until penultimate edge reached.} 
		\idone{BR produces sets $R_1, R_2,...$.}
		\idone{If no sets produced, no solution exists, end. Else if $\exists$ set such that $|R_i| = l$, use connecting procedure to join components together, solution found, end.}
		\idone{Else multiple sets need to be used, run MBR to find two or more sets that overlap correctly. If collection $\mathcal{R}^*$ found, connecting procedure on all sets in collection, solution found, end. Else, no solution exists, end.}
		\idone{Guaranteed to find solution, if one exists, in $O(n^2)$ time.}
		\idone{MBR types, check that Beckers method is redundant.}
		\idone{This is called the Alternating Hamiltonian Construction (AHC) algorithm.}
		\idone{BR sorts edges of $R'$.}
	\end{itemize}
}

\section{SCSPP}
\begin{itemize}
	\item Equations feasible candidate solution
	\item SCSPP at least as hard as BPP, NP-hard
	\item Why heuristics?
	\item lowerbound, optimal solution, theoretical minimum
	\item theoretical min less accurate
	\item State advantages and disadvantages of MFFD and MFFD$^+$
	\item Differences between SCSPP and BPP
\end{itemize}

{\color{myPink}
	\begin{itemize}[leftmargin=*]
		\item
		\idone{Feasible solution $\mathcal{S} = \{S_1,...,S_k\}$ and four conditions.}
		\idone{SCSPP at least as hard as BPP, NP-hard (SCSPP generalises BPP, assuming $P \neq NP$).}
		\idone{Cannot find solution in reasonable time, therefore use heuristics, near optimal solutions faster.}
		\idone{Lit review, heuristics used for BPP/SPP, FFD, BFD etc., how do these work with SCSPP? State how they could work with TPP/SDCL because of what was mentioned in introduction, but cannot guarantee feas solution for SCSPP due to VSC.}
		\idone{Optimal solution requires fewest number of strips $k$ to pack all items.}
		\idone{Lower bound for $k$ is theoretical minimum $t = \ceil*{\sum_{i=1}^{n}w_i / W}$.}
		\idone{Lowerbound cite Martello \cite{martello1990l}.}
		\idone{$t$ not accurate for SCSPP, doesn't take into account $\tau$, if $\tau >$ 2x largest score width then $n$ strips required, one for each item, regardless of item widths or strip width $W$.}
		\idone{May find optimal solution without knowing, as optimal number of strips for a given problem instance of the SCSPP may be greater than $t$.}
		\idone{Can we show a solution is optimal? If not, why?}
		\idone{Differences BPP and SCSPP: (1) Importance of order and orientation of items; (2) Feasibility of strips when adding/removing/rearranging items.}
		\idone{$\mathcal{F}$ denotes the set of all subsets $\mathcal{I}' \subseteq \mathcal{I}$ of items that can be feasibly packed onto a single strip, i.e. $\sum_{i \in S} w_i \leq W$ and VSC met.}
		\idone{Heuristics for SCSPP Hawa \cite{hawa2018}.} 
		\idone{Our implementation of AHC in MFFD$^+$ has the preliminary check, previous paper does not.}
		\idone{MFFD - FFD but only place item if score width on end of strip meets VSC with a score width on the item (check both orientations) - operates in the same way as FFD, except additional step of checking that VSC is met with one of the score widths of the item and the right-most score width on the strip, i.e. check that $S \cup \{i\} \in \mathcal{F}$.}
		\idone{MFFD$^+$ - FFD, incorporates AHC, instead of checking VSC on end of strip, run AHC using all items on strip and current item. If item fits on strip, run AHC on items on strip and current item. If solution found, replace current arrangement of items on strip with arrangement found by AHC including new item, else move on to next strip.}
		\idone{If item starts new strip, pack item in regular orientation, i.e. $(a_i, b_i)$, smaller score width on left-hand side.}
		\idone{ MFFD$^+$ can find solution for subset of items, rearrange all items, MFFD cannot, only place items on end.}
		\idone{MFFD may require extra strips for items even though feasible ordering exists using AHC.}
	\end{itemize}
}

\subsection{Heuristics}
\begin{itemize}
	\item For both heuristics, if current item is placed on a new strip, it is placed in a regular orientation - smaller score width on the left-most side of the strip.
	\item MFFD - operates in the same way as FFD, except additional step of checking that VSC is met with one of the score widths of the item and the right-most score width on the strip, i.e. check that $S \cup \{i\} \in \mathcal{F}$.
	\item MFFD$^+$ - if item fits on strip, run AHC on items on strip and current item. If solution found, replace current arrangement of items on strip with arrangement found by AHC including new item, else move on to next strip.
\end{itemize}

\subsection{Experimental Results - Heuristics}
\begin{itemize}
	\item Time it takes to run heuristics
	\item Tables of comparisons
	\item State that there are 20 types on average for real instances (no longer in table)
	\item Although MFFD$^+$ better than MFFD, still disadvantages
	\item Initially all items in decreasing order, may be a better ordering
	\item only packing one item at a time, one item may not be feasible on a strip but if two were packed at the same time could be feasible
	\item explain benefit of using Evolutionary algorithm, lead on to next section
\end{itemize}

{\color{myPink}
	\begin{itemize}[leftmargin=*]
		\item
		\idone{Artificial - items are strongly heterogeneous (different widths/score widths).}
		\idone{Real - items are weakly heterogeneous (many items have the same score widths/widths).}
		\idone{Solution quality $q = |\mathcal{S}|/ t$.}
		\idone{$t$, $q$, and $|\mathcal{S}|$ are all means from 1000 instances}
		\idone{Remove fitness from table.}
		\idone{MFFD only finds solutions == $t$ for real, 100, $W=2500$ (5 instances) and $W=5000$ (1 instance).}
		\idone{MFFD$^+$ find solutions == $t$ for artificial, 100, $W = 2500$ (26 instances) and $W=5000$ (7 instances), and real, 100, $W=2500$ (16 instances) amd $W=5000$ (5 instances).}
		\idone{Solution quality of MFFD$^+$ better (that is, closer to 1) than MFFD for every problem type on average.}
		\idone{Instances where $|\mathcal{S}|$ == $t$ know that opt solution found.}
		\idone{Could be instances where opt solution found but we are unable to show that it is optimal.}
		\idone{MFFD$^+$ slower, for each item AHC could be executed up to $|\mathcal{S}|$ times.}
		\idone{Running experiments again, this uses BCR and preliminary checks, unlike previous paper. }
		\idone{Table shows...}
		\idone{Time it takes to run heuristics.}
		\idone{State that there are 20 types on average for real instances (no longer in table).}
		\idone{MFFD$^+$ slower, could be a different ordering of items works better (rather than items in decreasing order of widths), one item at a time might not find feasible ordering, may be that feasible ordering exists when packing multiple items simultaneously.}
		\idone{Fast greedy heuristics not as good, other methods superior, therefore use evolutionary algorithm (lead on to next section).}
	\end{itemize}
}

\begin{table}[h!]
	\centering
	\caption{Results for $W=2500$}
	\begin{tabular}{cccccccc}\toprule
		& & &\multicolumn{2}{c}{MFFD} &\phantom{a}& \multicolumn{2}{c}{MFFD$^+$}\\
		\cmidrule{4-5} \cmidrule{7-8}
		Inst & Types &TMin & Strips & TMin$\%$ && Strips & TMin$\%$\\ \midrule	
		a,100 & 100 & tmin & - & - && - & - \\
		r,100 & 20 & tmin & - & - && - & -\\
		\midrule
		a,500 & 500 & tmin & - & - && - & -\\
		r,500 & 20 & tmin & - & - && - & -\\
		\bottomrule
	\end{tabular}	
	\label{table:MFFD2500}
\end{table}

\section{Notes}
\begin{itemize}
	\item ``Grouping problems involve a collection of ``items'' that are to be divided into a number of groups, subject to certain constraint'' \cite{lewis2009}
	\item ``Order Dependent Minimum Grouping Problems'' \cite{lewis2009}
	\item ``The term feasible is used exclusively to describe any candidate solution in which no problem-specific constraints are being violated'' \cite{lewis2009}
	\item ``An optimal solution for an ODMPG is thus any solution that uses $\chi$ feasible groups to contain the $n$ items'' \cite{lewis2009}
	\item ``An optimal solution can always be represented by a permutation of the items, since we can always generate such a permutation \textit{from} an optimal solution'' \cite{lewis2009}
	\item ``Note that none of the algorithms considered in this comparison ever allow a bin to be over-filled in a candidate solution, thus any group $g$ will always have $F(g) \leq C$'' \cite{lewis2009}
\end{itemize}


\section{Evolutionary Algorithm}
\begin{itemize}
	\item Create initial population, one solution using MFFD$^+$, the rest using MFFR$^+$
	\item Each solution in population is also mutated and local search is applied
	\item Choose two parent solutions from population
	\item Apply one of two recombination operators
	\item Paragraph for each operator, GGA, GPX', and GPN
	\item Explain why GPX cannot be used, cite Lewis paper
	\item Describe repair procedure using MFFD$^+$
	\item Section explaining Local Search, PairPair, PairSin, SinSin, MoveSin
	\item Note the use of feasPacking/infeasPacking sets to aid the search
	\item Reduces the number of times AHC needs to be called, for each group of items AHC should only be called once
	\item Preliminary check before calling AHC
	\item Once offspring is produced, calculate fitness of parents and offspring, replace worst parent with offspring in population
	\item GGA $1 \leq i < j \leq |\mathcal{S}_Y|$ \textbf{and} cannot have $i = 1 \land j = |\mathcal{S}_Y|$ unlike in Rhyd paper - ensures that at least 2 strips from $\mathcal{S}_Y$ are in offspring, and prevents all strips from $\mathcal{S}_Y$ from being selected, as this would mean that all strips from $\mathcal{S}_X$ would be deleted from the offspring, and so offspring will not have strips from both parents. Ensures that offspring has strips from both parents.
	\item Fitness $f(\mathcal{S}) = \frac{\sum_{S \in \mathcal{S}} (A(S)/W)^2}{|\mathcal{S}|}$ Falkenaur 1998
	\item Set $\mathcal{F}$ is set of all subsets of items $\mathcal{I}' \subseteq \mathcal{I}$ that can produce a feasible ordering.
	\item A feasible solution or strip means that the solution/strip abides by all constraints.
\end{itemize}

{\color{myRed}
	\begin{itemize}[leftmargin=*]
		\item
		\idone{Why use an EA? Lit review of EAs in BPP problems, benefits (repeated multiple times, best characteristics of strips/solutions).}
		\idone{Whenever subproblem occurs, AHC will be used.}
		\idone{Sets $\mathcal{A}$ and $\mathcal{B}$, subsets of items that produce feasible/infeasible orderings determined by AHC. Search these sets before calling AHC, therefore AHC used at most once for each distinct subset of items $\mathcal{I}' \subseteq \mathcal{I}$.}
		\idone{Feasible solution $\mathcal{S}$ means solution abides by all constraints.}
	\end{itemize}
}

\begin{itemize}
	\item Create 25 candidate solutions for initial population, one solution using MFFD$^+$, the others using MFFR$^+$ (items sorted in random order as opposed to decreasing order of widths), each solution is mutated before being inserted into the population.
	\item Each iteration of EA, two parent solutions $\mathcal{S}_1$ and $\mathcal{S}_2$ are chosen from the population at random, crossover operator used to create single offspring solution $\mathcal{S}$, which is then mutated before replacing the least fit parent solution in the population (breaking ties randomly).
	\item Fitness function $f(\mathcal{S}) = \frac{\sum_{S \in \mathcal{S}} (A(S)/W)^2}{|\mathcal{S}|}$ \cite{falkenauer1992}, $A(S) = \sum_{i \in S} w_i$ - ``fullness''/total width of all items on strip $S$, value between 0 and 1, closer to 1 = better packing, =1 means all strips are filled to capacity, perfect packing.
	\item Although two solutions $\mathcal{S}_1$ and $\mathcal{S}_2$ may contain the same number of strips/have the same size, fitness value identifies which solution contains a better packing of the items - distinguish between two solutions of the same size.
	\item Not only considering how many strips required to pack all items, but how those items are packed onto the strips (optimise how the strips are packed).
	\item Better packed strips means full capacity of strip is taken advantage of, reduce waste material on strips, plus nearly empty strips can be used to accommodate more items, or waste material can be reused.
	\item If the strips are packed well, fewer strips required, else if strips are not packed well, extra strips required to pack items that cannot be packed onto strips already being used.
	\item Take into account vicinal sum constraint - there may be two strips that are roughly equally filled, however even though it may seem that the items could be shuffled so that more are on one strip (thus a better packing), it may not be possible due to the constraint - not taken into account in other applications of this fitness value, however will still use this fitness value as our aim is to produce the best packing possible given the constraint.
\end{itemize}

{\color{myRed}
	\begin{itemize}[leftmargin=*]
		\item
		\idone{Create candidate solutions for initial population, one solution using MFFD$^+$, the others using MFFR$^+$ (items sorted in random order as opposed to decreasing order of widths), each solution is mutated before being inserted into the population.}
		\idone{Each iteration of EA, two parent solutions $\mathcal{S}_1$ and $\mathcal{S}_2$ are chosen from the population at random, crossover operator used to create single offspring solution $\mathcal{S}$, which is then mutated before replacing the least fit parent solution in the population (breaking ties randomly).}
		\idone{Fitness function $f(\mathcal{S}) = \frac{\sum_{S \in \mathcal{S}} (A(S)/W)^2}{|\mathcal{S}|}$ \cite{falkenauer1992}.}
		\idone{$A(S) = \sum_{i \in S} w_i$ - ``fullness''/total width of all items on strip $S$}
		\idone{value between 0 and 1, closer to 1 = better packing.}
		\idone{Although two solutions $\mathcal{S}_1$ and $\mathcal{S}_2$ may contain the same number of strips/have the same size, fitness value identifies which solution contains a better packing of the items - distinguish between two solutions of the same size.}
		\idone{Not only considering how many strips required to pack all items, but how those items are packed onto the strips (optimise how the strips are packed).}
		\idone{Better packed strips means full capacity of strip is taken advantage of, reduce waste material on strips, plus nearly empty strips can be used to accommodate more items, or waste material can be reused.}
		\idone{If the strips are packed well, fewer strips required, else if strips are not packed well, extra strips required to pack items that cannot be packed onto strips already being used.}
		\idone{Take into account vicinal sum constraint - there may be two strips that are roughly equally filled, however even though it may seem that the items could be shuffled so that more are on one strip (thus a better packing), it may not be possible due to the constraint - not taken into account in other applications of this fitness value, however will still use this fitness value as our aim is to produce the best packing possible given the constraint.}
		\idone{As an example, use fitness values from example solutions created using FFD/MFFD/MFFD$^+$ from Heuristics section figures.}
	\end{itemize}
}

\subsection{xover}
\begin{itemize}
	\item May have duplicate or missing items
	\item Note the differences between BPP and SCSPP, cannot simply remove individual items from strips, may cause the arrangement of remaining items to become infeasible (VSC not met between items)- hence why GPX cannot be used \cite{lewis2017}
	\item GGA $1 \leq i < j \leq |\mathcal{S}_Y|$ \textbf{and} cannot have $i = 1 \land j = |\mathcal{S}_Y|$ unlike in Rhyd paper - ensures that at least 2 strips from $\mathcal{S}_Y$ are in offspring, and prevents all strips from $\mathcal{S}_Y$ from being selected, as this would mean that all strips from $\mathcal{S}_X$ would be deleted from the offspring, and so offspring will not have strips from both parents. Ensures that offspring has strips from both parents.
	\item If missing items, repair procedure, then local search
	\item GGA - Permute strips of second parent solution, then choose two strips randomly, add all strips between two chosen strips (including chosen strips) and add to offspring. Then from first parent, only add strips to offspring containing items that are not in offspring. Repair procedure on missing items, if any.
	\item GPX' - Alternate between parent solutions, add fullest strip to offspring, delete strips from other parent containing items in offspring. Continue until $min(|\mathcal{S}_X|,|\mathcal{S}_Y|)-1$ strips in offspring. Repair procedure on missing items, if any. Initially, if both parents have fullest strip, break ties randomly.
	\item GPN - Operates in the same manner as GPX', except chose strip containing the most items. Initially, if both parents have strip containing same number of max items, choose the parent whose strip is the fullest. If equal for both strips, choose randomly.
	\item Once offspring produced, mutate and apply local search before replacing worst parent.
\end{itemize}

{\color{myRed}
	\begin{itemize}[leftmargin=*]
		\item
		\idone{Purpose of recombination/crossover, select best characteristics of each parent solution to form offspring.} 
		\idone{Prevent duplicate items.}
		\idone{Note the differences between BPP and SCSPP, cannot simply remove individual items from strips, may cause the arrangement of remaining items to become infeasible (VSC not met between items).}
		\idone{GGA Falkenauer \cite{falkenauer1992}, permute strips of $\mathcal{S}_2$, select two strips, take all strips between and including these strips and put into offspring solution $\mathcal{S}$. Add from $\mathcal{S}_1$ strips that do not contain items already in offspring. Note, choose strips $1 \leq i < j \leq |\mathcal{S}_2|$ \textbf{and} cannot have $i = 1 \land j = |\mathcal{S}_2|$ unlike in Rhyd paper - ensures that at least 2 strips from $\mathcal{S}_2$ are in offspring, and prevents all strips from $\mathcal{S}_2$ from being selected, as this would mean that all strips from $\mathcal{S}_1$ would be deleted from the offspring, and so offspring will not have strips from both parents. Ensures that offspring has characteristics from both parents.}
		\idone{GPX', Quiroz \cite{quiroz2015} (check) - Alternate between parent solutions, add fullest strip to offspring, delete strips from other parent containing items in offspring. Continue until $min(|\mathcal{S}_1|,|\mathcal{S}_2|)-1$ strips in offspring. Initially, if both parents have fullest strip, break ties randomly.}
		\idone{GPN - Operates in the same manner as GPX', except chose strip containing the most items.} 
		\idone{Initially, if both parents have strip containing same number of max items, choose the parent whose strip is the fullest. If equal for both strips, choose randomly.} 
		\idone{What does each xOver aim to do? Prevent duplicates (by deleting strips from other parent).}
		\idone{Missing items, apply MFFD$^+$ to produce partial solution $\mathcal{S}_Y$, then apply Local search (described in next section) on offspring and $\mathcal{S}_Y$ to produce full offspring $\mathcal{S}$}
		\idone{Many missing items in comparison to BPP as cannot delete individual items due to VSC, have to delete entire strips, could contain items not yet in offspring.}
	\end{itemize}
}

\subsection{LocalSearch}
\begin{itemize}
	\item If stage four completed then reduce number of strips in $\mathcal{S}_Y$ by 1.
	\item MFFD$^+$ on $\mathcal{S}_Y$ to create $\mathcal{S}_Y'$, means that $|\mathcal{S}_Y'| \leq |\mathcal{S}_Y|$.
	\item Based on dominance criterion of \cite{martello1990l}
	\item If strip $S_1$ dominates $S_2$, then a solution containing $S_1$ will not have more strips than a solution containing $S_2$
	\item Well-filled strips with larger items are always preferrable over less-filled strips with smaller items \cite{levine2004}
	\item HGGA \cite{falkenauer1996} searches locally for dominant strips by replacing items in the strips with larger free items. At the same time, the free items are replaced by smaller items from the strips, which makes it easier to place them back into the solution afterwards
	\item Aim is to move items between (\cite{lewis2009} uses full solutions, not partial) the solutions in such a way that the ``fullness'' of each strip in $\mathcal{S}_1$ increases, while the number of items within each strip does not. This operator also moves smaller items into $\mathcal{S}_2$, useful, smaller items easier to pack than larger items.
	\item Items are interchanged between strips such that wastage within strips in $\mathcal{S}$ decreases, while the number of items in each strip in $\mathcal{S}$ remains the same or also decreases. \cite{lewis2017}
	\item Initially permute the strips of both solutions
	\item Clearly at each stage the swap/move can only be performed if the strips remain feasible (i.e. not overfilled and feasible ordering of the items)
	\item Therefore at each stage an instance of the subproblem occurs
	\item Once a swap/move has been performed (once a stage has completed), the procedure moves on to the next stage.
	\item \cite{lewis2009}, \cite{levine2004}, \cite{falkenauer1996}, \cite{martello1990l}
	\item Repeating process creates different subsets of items on each strip, different feasible combinations
	\item Different subsets of items on each strip means more possibility to move item(s)
	\item E.g. could be that an item from $\mathcal{S}_Y$ can't be moved to a strip in $\mathcal{S}_X$ because there is no feasible ordering of the items on the strip including the item from $\mathcal{S}_Y$. By repeating local search, it could create a different subset of items on the strip that could produce a feasible ordering with an item from $\mathcal{S}_Y$. - rewrite
	\item Could be that there is a feasible ordering of the items on the strip in $\mathcal{S}_X$ (including the new items from $\mathcal{S}_Y$ and without the items being moved), but there is no feasible ordering of the items on the strip in $\mathcal{S}_Y$ (which includes the items from the strip in $\mathcal{S}_X$ and excludes the items being swapped). Then the items cannot be swapped, because both strips from $\mathcal{S}_X$ and $\mathcal{S}_Y$ must be feasible. 
	\item This means local search takes longer, fewer swaps than seen in \cite{lewis2009}, \cite{lewis2017}, \cite{levine2004}, \cite{falkenauer1996} (check)
\end{itemize}

{\color{myRed}
	\begin{itemize}[leftmargin=*]
		\item
		\idone{Purpose of local search, takes two partial solutions $\mathcal{S}_X$ and $\mathcal{S}_Y$.}
		\idone{Initially permute strips.}
		\idone{4 stages, 3 swap, 1 move. width of items from $\mathcal{S}_X$ must be less than width of items from $\mathcal{S}_Y$ in first three stages.}
		\idone{Moves smaller items into $\mathcal{S}_Y$, larger items into $\mathcal{S}_X$.}
		\idone{If swap/move performed, move onto next stage. Repeat until no changes to either partial solution.}
		\idone{MFFD$^+$ applied on items in $\mathcal{S}_Y$ to produce partial solution $\mathcal{S}_Y'$. Then strips from $\mathcal{S}_X$ and $\mathcal{S}_Y'$ inserted into $\mathcal{S}$ (this is not necessarily offspring).}
		\idone{Based on dominance criterion of Martello and Toth \cite{martello1990l}.}
		\idone{If strip $S_1$ dominates $S_2$, the a solution using $S_1$ will have no more strips than a solution using $S_2$.}
		\idone{Aim - increase fullness of strips in $\mathcal{S}_X$ while maintaining or decreasing number of items on strips.}
		\idone{Moves smaller items into $\mathcal{S}_Y$, easier to repack in stage (4).}
		\idone{Variations of procedure seen in Falkenauer \cite{falkenauer1996}, Lewis \cite{lewis2009} \cite{lewis2017}, Levine \cite{levine2004}.}
		\idone{VSC makes swaps/moves more difficult, this means local search takes longer, fewer swaps than seen in \cite{lewis2009}, \cite{lewis2017}, \cite{levine2004}, \cite{falkenauer1996} (check).}
		\idone{Repeating process produces different combinations of items, more possibilities to find feasible ordering.}
		\idone{Well-filled strips with larger items preferable over less-filled strips with smaller items (Levine \cite{levine2004}).}
	\end{itemize}
}


\subsection{Problem Instances}
\begin{itemize}
	\item Types of instances - artificial, real
	\item Problem instance generator will produce 1000 instances for four different sets, number of items = 100 and 500 and artificial and real instances, 4000 problem instances in total
	\item Each of these sets will then be run 6 times using different arguments - strip width = 2500 and 5000, and either GGA, GPX', or GPN
	\item Overall there will be 24 types of outputs from EA
	\item In EA output file to compare:
	\begin{itemize}
		\item Proportion of times feasPacking/infeasPacking sets used instead of AHC
		\item Number of strips in best solution found
		\item Number of iterations of EA within the given time limit
		\item Fitness value of the best solution found
		\item If best solution found is equivalent to the lowerbound
	\end{itemize}
	\item Keep track of best fitness/best solution/time at each iteration, if better solution found then write to file, produce graph
\item At the end of each EA iteration, add all strips from offspring to feasPacking set to use in post optimisation phase
\item Number of items - 100, 500
\item Time limit for EA - 10 minutes
\item Width of strips - 2500, 5000
\item Recombination operators - GGA, GPX', GPN
\end{itemize}


\begin{algorithm}
\caption{\textsc{EvolutionaryAlgorithm} \textit{pop}, $\mathcal{S}_X, \mathcal{S}_Y$, \textit{offspring}}
\begin{algorithmic}
	\State Choose two solutions k and l randomly from \textit{pop}
	\State $\mathcal{S}_X$ = $pop[k]$ //parent1
	\State $\mathcal{S}_Y$ = $pop[l]$ //parent2
	\State parent1Fit = Fitness($\mathcal{S}_X$)
	\State parent2Fit = Fitness($\mathcal{S}_Y$)
	\Run Crossover Operator with $\mathcal{S}_X$ and $\mathcal{S}_Y$, \Output $offspring$
	\State $feasPacking \gets feasPacking + offspring$
	\State offFit = Fitness($offspring$)
	\If{$parent1Fit < parent2Fit$}
		\State replace pop[k] with offspring
	\ElsIf{$parent1Fit > parent2Fit$}
		\State replace pop[l] with offspring
	\ElsIf{$parent1Fit == parent2Fit$}
		\State $r$ = random value between 0 and 1
		\If{$r < 0.5$}
			\State replace pop[k] with offspring
		\ElsIf{$r >= 0.5$}
			\State replace pop[l] with offspring
		\EndIf		
	\EndIf	
\end{algorithmic}	
\end{algorithm}	

\begin{algorithm}
	\caption{\textsc{LocalSearch}}
	\begin{algorithmic}
		\State local search
	\end{algorithmic}	
\end{algorithm}

\begin{table}[h!]
	\centering
	\caption{Results for $W=2500$}
	\begin{tabular}{ccccccccccc}\toprule
		& & &\multicolumn{2}{c}{GGA} &\phantom{a}& \multicolumn{2}{c}{GPX'} &\phantom{a}& \multicolumn{2}{c}{GPN}\\
		\cmidrule{4-5} \cmidrule{7-8} \cmidrule{10-11}
		Inst & Types &TMin & Strips & TMin$\%$ && Strips & TMin$\%$ && Strips & TMin$\%$ \\ \midrule	
		a,100 & 100 & tmin & - & - && - & - && - & -\\
		r,100 & 20 & tmin & - & - && - & - && - & -\\
		\midrule
		a,500 & 500 & tmin & - & - && - & - && - & -\\
		r,500 & 20 & tmin & - & - && - & - && - & -\\
		\bottomrule
	\end{tabular}	
	\label{table:EA2500}
\end{table}


\section{Post-optimization}
\begin{itemize}
	\item Exact cover formulation, NP-hard, state the IP, describe DLX
	\item Use strips in feasPacking for post opt
	\item Compare with EA output - is a better solution found, or a solution with the same number of strips but a better fitness value?
	\item Is the post opt phase able to find a solution equal to the lowerbound?
	\item Post opt will only ever find a solution equal to or better than the solution found in EA, never worse
	\item Execution time
\end{itemize}

{\color{myGreen}
	\begin{itemize}[leftmargin=*]
		\item Cite Malaguti \cite{malaguti2008}.
		\item Exact cover formulation, NP-hard, state the IP, describe DLX.
		\item Cite Knuth \cite{knuth2000} dancing steps.
		\item Use strips in feasPacking for post opt.
		\item Compare with EA output - is a better solution found, or a solution with the same number of strips but a better fitness value?
		\item Is the post opt phase able to find a solution equal to the lowerbound?
		\item Post opt will only ever find a solution equal to or better than the solution found in EA, never worse.
		\item Execution time.
		\item Set cover problem is optimisation problem, find min number of sets.
		\item Exact cover problem is decision problem, does a set exist.
		\item However since we add every item on its own strip to feasPacking, we know that a set exists.
		\item Problem is to find minimum number of strips that covers all items and contains every item exactly once.
		\idone{$A = (a_{ij})$ - $m$ x $n$ matrix.}
		\idone{$M = \{1, 2,..., m\}$ - rows of the matrix, each row $i \in M$ is a strip.}
		\idone{$N = \{1, 2,...,n\}$ - columns of the matrix, each column $j \in N$ is an item.}
		\idone{$(a_{ij}) = 1$ iff item $j$ is on strip $i$.}
		\idone{Say that row $i$ covers column $j$ if $a_{ij} = 1$.}
		\idone{Find the smallest number of strips $S \subseteq M$ that contains every item exactly once, i.e. union of strips $= \mathcal{I}$ and intersection $= \emptyset$.}
		\idone{Find minimum cardinality subset $S \subseteq M$ of rows such that each column $j \in N$ is covered by exactly one row $i \in S$.}
		\item Xpress mosel model.
	\end{itemize}
}

\section{Experimental Results}
\begin{itemize}
	\item Proportion of instances where best solution EA == lowerbound
	\item Proportion of instance where best solution post opt better than EA, and/or == lowerbound
	\item Comparison between GGA and GPX', artificial and real instance types, different strip widths and number of items
	\item check timestamps from EA output file - which type is able to reach a better solution at a faster rate?
	\item Differences in number of strips in best solution found in EA using different arguments
	\item Exact cover formulation, NP-hard, state the IP, describe DLX
	\item cite Knuth dancing steps
	\item Use strips in feasPacking for post opt
	\item Compare with EA output - is a better solution found, or a solution with the same number of strips but a better fitness value?
	\item Is the post opt phase able to find a solution equal to the lowerbound?
	\item Post opt will only ever find a solution equal to or better than the solution found in EA, never worse
	\item Execution time
	\item Set cover problem is optimisation problem, find min number of sets
	\item exact cover problem is decision problem, does a set exist
	\item however since we add every item on its own strip to feasPacking, we know that a set exists
	\item problem is to find minimum number of strips that covers all items and contains every item exactly once
	\item $A = (a_{ij})$ - $m$ x $n$ matrix
	\item $M = \{1, 2,..., m\}$ - rows of the matrix, each row $i \in M$ is a strip
	\item $N = \{1, 2,...,n\}$ - columns of the matrix, each column $j \in N$ is an item
	\item $(a_{ij}) = 1$ iff item $j$ is on strip $i$
	\item Say that row $i$ covers column $j$ if $a_{ij} = 1$
	\item Find the smallest number of strips $S \subseteq M$ that contains every item exactly once, i.e. union of strips $= \mathcal{I}$ and intersection $= \emptyset$
	\item Find minimum cardinality subset $S \subseteq M$ of rows such that each column $j \in N$ is covered by exactly one row $i \in S$
	\item Xpress mosel model
\end{itemize}

\section{Conclusion}
\begin{itemize}
	\item Could use selected packings rather than all packings
\end{itemize}


\bibliographystyle{elsarticle-num}
\bibliography{includes/bibliography}

\end{document}