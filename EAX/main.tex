\documentclass{elsarticle}

\input{includes/preamble.tex}

\begin{document}
	
\begin{frontmatter}
\title{An Evolutionary Algorithm for the Score-Constrained Strip-Packing Problem}
\author{Asyl L. Hawa}
\author{Rhyd Lewis}
\author{Jonathan M. Thompson}
\address{School of Mathematics, Cardiff University, Senghennydd Road, Cardiff, UK}
\end{frontmatter}

\begin{comment}
1. Introduction - sec:intro
2. AHC - sec:ahc
3. Heuristics for the SCSPP - sec:scspp
3.1. Heuristics - sub:heuristics
3.2. Experimental Results - Heuristics - sub:expheuristics
4. EA - sec:ea
4.1. Crossover Operators - sub:xover
4.2. Local Search - sub:localsearch
4.3. Mutation - sub:mutation
4.4. EA Process - sub:eaframework
4.5. Experimental Results - EA - sub:expea
5. Postoptimisation - sec:postopt
5.1. Experimental Results - Postoptimisation - sub:exppostopt
6. Conclusion - sec:conclusion
\end{comment}

%--------------------------------------------------------------------

\section{Introduction}
\label{sec:intro}
A set $\mathcal{I}$ of $n$ rectangular cardboard items of equal height $H$ and varying widths $w_i \in \mathbb{Z}^+$ are to be packed on a strip from left to right. Each item $i \in \mathcal{I}$ is marked with two vertical lines, called score lines, in predetermined places. The distance between each score line and the edge of the item are score widths, $a_i, b_i \in \mathbb{Z}^+$. Once the items are packed onto the strip, a pair of knives on a bar simultaneously cut along the score lines of two adjacent items to aid the folding process. Due to the manner in which the knives are secured onto the bar, the knives must maintain a set distance from one another, a so-called ``minimum scoring distance''. Therefore, in order for the knives to score all of the items in the correct locations, the distance between two score lines of adjacent items must exceed the minimum scoring distance. Hence, the problem involves packing the items onto the strip in such a way that the sum of all adjacent score widths exceeds the minimum scoring distance, as stated in the following definition:

\begin{definition}
	\label{defn:subprob}
	Let $\mathcal{I}$ be a set of items with widths $w_i \in \mathbb{Z}^+$, score widths $a_i, b_i \in \mathbb{Z}^+$, and equal height $H$. Given a minimum scoring distance $\tau$, the Score-Constrained Packing Sub-Problem (SCPSP) involves finding an arrangement of the items in $\mathcal{I}$ such that the sum of every pair of adjacent score widths is greater than or equal to $\tau$.
\end{definition}

\begin{definition}
	Let $\mathcal{M}$ be a multiset of unordered pairs, $\mathcal{M} = \{\{a_1, b_i\}, \{a_2, b_2\},..., \{a_n, b_n\}\}$, $a_i, b_i \in \mathbb{Z}^+$, and let $\mathcal{T}$ be an ordering of the elements of $\mathcal{M}$ such that each element is a tuple. Given a fixed value $\tau \in \mathbb{Z}^+$, the Constrained Ordering Problem (COP) consists of finding a solution $\mathcal{T}$ such that
	\begin{equation}
		\label{eqn:vsc}
		\emph{\textbf{rhs}}(i) + \emph{\textbf{lhs}}(i+1) \geq \tau \hspace{5mm} \forall \hspace{1mm} i \in \{1,2,..., n-1\},
	\end{equation}
	where \emph{\textbf{lhs}($i$)} and \emph{\textbf{rhs}($i$)} denote the left- and right-hand values of the $i$th tuple. The inequality is referred to as the \emph{vicinal sum constraint}.
\end{definition}

For example, given the COP instance $\mathcal{M} = \{\{1,2\}, \{1,6\}, \{2,3\}, \{2,4\}, \{3,5\}, \{4,5\}\}$, we have a solution $\mathcal{T} = \langle(1,6), (2,4), (3,5), (2,3), (4,5), (2,1)\rangle$

\begin{definition}
	Let $\mathcal{I}$ be a set of $n$ rectangular items of height $H$ with varying widths $w_i \in \mathbb{Z}^+$ and score widths $a_i, b_i \in \mathbb{Z}^+$ for each item $i \in \mathcal{I}$. Given a minimum scoring distance $\tau \in \mathbb{Z}^+$, the Score-Constrained Strip-Packing Problem (SCSPP) consists of finding the minimum number of strips of height $H$ and width $W$ required to pack all items in $\mathcal{I}$ such that the sum of every pair of adjacent score widths is greater than or equal to $\tau$ and no strip is overfilled.
\end{definition}

\begin{figure}	
	\centering
	\begin{subfigure}[h]{0.45\textwidth}
		\includestandalone[width=\textwidth]{figures/items}
		\label{fig:items}
	\end{subfigure} 
	\begin{subfigure}[h]{0.75\textwidth}
		\includestandalone[width=\textwidth]{figures/itemsaligned}
		\label{fig:itemsaligned}
	\end{subfigure}
	\caption{Example of a single strip-packing problem and a corresponding solution with $\tau = 7$.}
	\label{fig:items/aligned}
\end{figure}

In the next section, we will provide a brief overview of the polynomial-time algorithm used to solve the COP. Section 3 will explain the difficulties associated with the SCSPP, and analyse bespoke heuristics. An evolutionary algorithm for the SCSPP is detailed in Section 4, along with results from rigorous experiments.  

\begin{itemize}
	\item Description of SCSPP, pack from left to right, minimum scoring distance.
	\item Formal definitions COP, subproblem (single strip problem), SCSPP (multi-strip) problem, vicinal sum constraint.
	\item Describe other problems using COP - TSP, 2 cities each state?
	\item $2^{n-1} n!$ distinct orderings, combinatorial explosion.
	\item $a_i, b_i, w_i, \mathcal{I}, \mathcal{I}', W, H, \tau, |\mathcal{I}| = n$.
	\item $(a_i, b_i)$, $(b_i, a_i)$ orientations (regular and rotated).
	\item Cite Goulimis \cite{goulimis2004}, Becker \cite{becker2015}, Lewis \cite{lewis2011} (Lewis TSP method), Hawa \cite{hawa2018}.
	\item Need to decide which strip to pack each item, and \emph{how}, i.e. what order and orientation should the items be in.
	\item Show that the subproblem is equivalent to the COP, minimum scoring distance = VSC.
	\item BPP special case of SCSPP with $\tau = 0$, NP-hard.
	\item $\tau$ = 70mm approx in industry. 
	\item COP/subproblem the strips have infinite width, SCSPP strips have finite width.
	\item Outermost score widths ignored.
	\item Items can be run through machine individually but extra time/cost.
	\item Lit review BPP/SPP, Garraffa \cite{garraffa2016}.
	\item Grouping problems, ODMGPs Lewis \cite{lewis2009}, other examples, formula for feas solution MGPs basic BPP.
	\item Two phase approach, EA then postopt, Malaguti \cite{malaguti2008}.
	\item Example instance $\mathcal{M}$ of COP and possible solution $\mathcal{T}$.
	\item Call the two phase process EAX?
	\item Polynomial-time algorithm for COP Hawa \cite{hawa2018}.
	\item Describe rest of paper/layout.
\end{itemize}


\section{AHC}
\label{sec:ahc}
From the instance $\mathcal{M}$ of the COP, we produce a graph $G$ consisting of $2n$ vertices, one for each element of $\mathcal{M}$, in non-decreasing order. An extra pair of dominating vertices is added to $G$, which have values equal to $\tau$. $G$ comprises two edge sets: $B$, which contains edges between vertices that are partners (that is, whose values make up a pair in $\mathcal{M}$); and $R$, which contains edges between vertices whose values add up to greater than or equal to $\tau$, and that are not partners. \textcolor{OrangeRed}{THRESHOLD GRAPH FIGURE}

A Hamiltonian cycle on a graph $G$ is a cycle that visits every vertex of $G$ exactly once. From this, we define a specific type of Hamiltonian cycle:

\begin{definition}
	\label{defn:althamcycle}
	Let $G = (V, B \cup R)$ be a simple, undirected graph where each edge is a member of one of two sets, $B$ or $R$. $G$ contains an alternating Hamiltonian cycle if there exists a Hamiltonian cycle such that successive edges alternate between sets $B$ and $R$.
\end{definition}

Due to the manner in which $G$ is constructed, it can be seen that the edges in $R$ represents all possible pairings of values from different pairs that meet the vicinal sum constraint. All pairs of elements must be present in the final solution, and so the edges in $B$ cannot be altered or removed. Clearly, an alternating Hamiltonian cycle on $G$ corresponds to a feasible ordering $\mathcal{T}$. Therefore, our task involves finding a matching $R' \subseteq R$ that, together with the edges in $B$, forms an alternating Hamiltonian cycle on $G$.

The Maximum Cardinality Matching (MCM) algorithm is used to produce a matching $R'$ from $R$. MCM takes each vertex $v_1, v_2,...,v_{2n+2}$ and adds to $R'$ the edge from $R$ connecting $v_i$ to the highest-indexed vertex $v_j$ that is not incident to an edge in $R'$. Pairs of vertices incident to edges in $R'$ are said to be ``matched''.

BR searches for an edge whose lower-indexed vertex is adjacent to the next edge's higher-indexed vertex, and that is not in the same component of $G'$ as the next edge. This edge starts the set $R_1$, and succeeding edges are added to $R_1$ provided the conditions hold and the next edge is not in the same component as any of the edges in $R_1$. BR continues through the list creating these sets until the penultimate edge has been reached. 

\begin{figure}[H]	
	\centering
	\begin{subfigure}[h]{0.4\textwidth}
		\includestandalone[width=\textwidth]{figures/matching}
	\end{subfigure} \quad
	\begin{subfigure}[h]{0.4\textwidth}
		\includestandalone[width=\textwidth]{figures/mps}
	\end{subfigure}
	\caption{Subgraph $G'= (V, B \cup R')$ created after MCM. When in planar form, it is clear that $l = 2$.}
	\label{fig:mps}
\end{figure}

\begin{itemize}
	\item Exact Polynomial-time algorithm for COP Becker \cite{becker2015} Hawa \cite{hawa2018}.
	\item Model instance graphically, graph $G$ with $V = \{v_1, ...v_{2n}\}$ vertices, one for each value in $\mathcal{M}$ in non-decreasing order.
	\item Preliminary checks using elements, explain, speed, Lewis \cite{lewis2011}.
	\item Add two dominating vertices, will be removed at the end, have value equal to $\tau$, therefore $G$ has $2n+2$ vertices.
	\item $B$, blue edges between ``partners'' (values that make up a pair in $\mathcal{M}$), $|B| = n+1$, perfect matching (dominating vertices are partners).
	\item Bijective function partners, $p : V \to V$, $p(v_i) = v_j$.
	\item $R$, red edges between vertices whose values add up to $\tau$/meet VSC and are not partners.
	\item Then we have a graph $G = (V, B \cup R)$ (see figure).
	\item Define Ham cycle, formal definition alt Ham cycle.
	\item $R$ = all possible pairings of values, $B$ cannot be altered, all edges must remain, as each edge represents a pair of values.
	\item Therefore aim is to find set of edges from $R$ that forms alt Ham cycle with $B$.
	\item Ham cycle NP-complete, Karp \cite{karp1972}, alt Ham generalises Ham cycle, Haggkvist \cite{haggkvist1977} proposition, special structure of graphs means can solve in polynomial-time.
	\item MCM - match each vertex with largest possible vertex, create set $R'$.
	\item Explain ``matched'', bijective function.
	\item Swap of partners.
	\item If $|R'| < n+1$, no solution exists, not enough edges to form cycle, end. Else if $|R'| = n+1$, i.e. matching, then $G' = (V, B \cup R')$ is 2-reg graph, consists of cycles $C_1,...,C_l$.
	\item If $l = 1$, then $G'$ is alt ham cycle, solution found, end (remove dom vertices). Else we need to find edges from $R\backslash R'$ that can act as bridges between the components and join them together into a single cycle. 
	\item Use BR to find these edges. List edges in order, go through to find edges that meet specific conditions. Continue until penultimate edge reached. BR produces sets $R_1, R_2,...$.
	\item If no sets produced, no solution exists, end. Else if $\exists$ set such that $|R_i| = l$, use connecting procedure to join components together, solution found, end.
	\item Else multiple sets need to be used, run MBR to find two or more sets that overlap correctly. If collection $\mathcal{R}^*$ found, connecting procedure on all sets in collection, solution found, end. Else, no solution exists, end.
	\item Guaranteed to find solution, if one exists, in $O(n^2)$ time.
	\item MBR types, check that Beckers method is redundant.
	\item This is called the Alternating Hamiltonian Construction (AHC) algorithm.
\end{itemize}

\section{Heuristics for the SCSPP}
\label{sec:scspp}
For an instance of the SCSPP, a feasible solution is represented by the set $\mathcal{S} = \{S_1, S_2, ..., S_k\}$ such that
\begin{subequations}
	\begin{align}
	\bigcup\nolimits_{i=1}^{|\mathcal{S}|} S_i &= \mathcal{I}, \label{eqn:packall}\\[3pt]
	S_i \cap S_j &= \emptyset \hspace{5mm} \forall \hspace{1mm} i, j \in \{1, 2, ..., |\mathcal{S}|\}, \hspace{2mm} i \neq j, \label{eqn:nooverlap} \\[3pt]
	\sum\nolimits_{i=1}^{|S_j|}w_i & \leq W \hspace{3mm} \forall \hspace{1mm} S_j \in \mathcal{S}, \label{eqn:capacity} \\[3pt]
	\textup{\textbf{rhs}}(i) + \textup{\textbf{lhs}}(i+1) &\geq \tau \hspace {5mm} \forall \hspace{1mm} i \in \{1, 2, ..., |S_j|-1\}, \hspace{2mm} \forall \hspace{1mm} S_j \in \mathcal{S}. \label{eqn:vscstrip}
	\end{align}
\end{subequations}

\subsection{Heuristics}
\label{sub:heuristics}

\begin{itemize}
	\item Feasible solution $\mathcal{S} = \{S_1,...,S_k\}$ and four conditions.
	\item SCSPP at least as hard as BPP, NP-hard (SCSPP generalises BPP, assumming $P \neq NP$).
	\item Cannot find solution in reasonable time, therefore use heuristics, near optimal solutions faster.
	\item Lit review, heuristics used for BPP/SPP, FFD, BFD etc., how do these work with SCSPP (or ODMGPs in general).
	\item Optimal solution requires fewest number of strips $k$ to pack all items.
	\item Lower bound for $k$ is theoretical minimum $t = \ceil*{\sum_{i=1}^{n}w_i / W}$, Martello \cite{martello1990l}.
	\item $t$ not accurate for SCSPP, doesn't take into account $\tau$, if $\tau >$ 2x largest score width then $n$ strips required, one for each item, regardless of item widths or strip width $W$.
	\item May find optimal solution without knowing, as optimal number of strips for a given problem instance of the SCSPP may be greater than $t$.
	\item Can we show a solution is optimal? If not, why?
	\item Differences BPP and SCSPP: (1) Importance of order and orientation of items; (2) Feasibility of strips when adding/removing/rearranging items.
	\item $\mathcal{F}$ denotes the set of all subsets $\mathcal{I}' \subseteq \mathcal{I}$ of items that can be feasibly packed onto a single strip, i.e. $\sum_{i \in S} w_i \leq W$ and VSC met.
	\item Heuristics for SCSPP Hawa \cite{hawa2018}, with addition of preliminary checks.
	\item MFFD - FFD but only place item if score width on end of strip meets VSC with a score width on the item (check both orientations) - operates in the same way as FFD, except additional step of checking that VSC is met with one of the score widths of the item and the right-most score width on the strip, i.e. check that $S \cup \{i\} \in \mathcal{F}$.
	\item MFFD$^+$ - FFD, incorporates AHC, instead of checking VSC on end of strip, run AHC using all items on strip and current item. If item fits on strip, run AHC on items on strip and current item. If solution found, replace current arrangement of items on strip with arrangement found by AHC including new item, else move on to next strip.
	\item If item starts new strip, pack item in regular orientation, i.e. $(a_i, b_i)$, smaller score width on left-hand side.
	\item MFFD$^+$ can find solution for subset of items, rearrange all items, MFFD cannot, only place items on end.
	\item MFFD may require extra strips for items even though feasible ordering exists using AHC.
	\item MFFD$^+$ slower, could be a different ordering of items works better (rather than items in decreasing order of widths), one item at a time might not find feasible ordering, may be that feasible ordering exists when packing multiple items simultaneously.
	\item Therefore use evolutionary algorithm (lead on to next section).
\end{itemize}


\subsection{Experimental Results - Heuristics}
\label{sub:expheuristics}
For our experiments, we produced two different types of instances: ``artificial'' instances, which contain items of varying widths and score widths; and ``real'' instances, which have multiple items of the same dimension. For each type 1000 instances were generated using sets of 100 and 500 items, giving a total of 4000 problem instances. For all instances, the minimum scoring distance $\tau$ was set to 70mm - the industry standard. All items have widths $w_i \in [150,1000]$ and score widths $a_i, b_i \in [1,70]$ selected uniform randomly, and equal height $H=1$. To compare our heuristics, we use two different strips widths, 2500 and 5000.

\begin{table}[h!]
	\centering
\caption{MFFD vs MFFD$^+$}
\begin{threeparttable}
\begin{tabular}{cccccccccccc}\toprule
	& & & \multicolumn{4}{c}{MFFD} &\phantom{a}& \multicolumn{4}{c}{MFFD$^+$}\\
	\cmidrule{4-7} \cmidrule{9-12}
	Instance & $W$ & $t$ & $|\mathcal{S}|$\tnote{1} & $\# t$ & $q$ & $f(\mathcal{S})$ && $|\mathcal{S}|$ & $\# t$ & $q$ & $f(\mathcal{S})$\\ \midrule	
	a,100 & 2500 & 23.323 & 30.754 & 0 & 1.320 & 0.686 && 28.457 & 26 & 1.221 & 0.771 \\
	a,100 & 5000 & 11.922 & 23.583 & 0 & 1.982 & 0.412 && 19.881 & 7 & 1.670 & 0.543  \\
	\midrule
	a,500 & 2500 & 114.942 & 140.206 & 0 & 1.220 & 0.781 && 132.647 & 0 & 1.154 & 0.842 \\
	a,500 & 5000 & 57.722 & 103.209 & 0 & 1.789 & 0.499 && 89.544 & 0 & 1.552 & 0.609 \\
	\midrule
	\midrule
	r,100 & 2500 & 23.473 & 37.069 & 5 & 1.600 & 0.549 && 35.419 & 16 & 1.523 & 0.597 \\
	r,100 & 5000 & 11.981 & 32.348 & 1 & 2.731 & 0.288 && 29.611 & 5 & 2.497 & 0.347 \\
	\midrule
	r,500 & 2500 & 115.239 & 184.106 & 0 & 1.612 & 0.552 && 177.249 & 0 & 1.551 & 0.593 \\
	r,500 & 5000 & 57.865 & 163.819 & 0 & 2.860 & 0.279 && 153.416 & 0 & 2.678 & 0.322 \\
	\bottomrule
\end{tabular}
\begin{tablenotes}
	\item[1] Mean from 1000 instances
\end{tablenotes}	
\end{threeparttable}	
\label{table:MFFD}
\end{table}

\begin{table}[h!]
\centering
\caption{average number of items per strip - MFFD vs MFFD$^+$}
	\begin{tabular}{ccccc}\toprule
		Instance & $W$ & items/lb & MFFD & MFFD$^+$ \\ \midrule	
		a,100 & 2500 & 4.288 & 3.252 & 3.514 \\
		a,100 & 5000 & 8.388 & 4.240 & 5.030 \\
		\midrule
		a,500 & 2500 & 4.350 & 3.566 & 3.769 \\
		a,500 & 5000 & 8.662 & 4.845 & 5.584 \\
		\midrule
		\midrule
		r,100 & 2500 & 4.260 & 2.698 & 2.823 \\
		r,100 & 5000 & 8.347 & 3.091 & 3.377 \\
		\midrule
		r,500 & 2500 & 4.339 & 2.716 & 2.821 \\
		r,500 & 5000 & 8.641 & 3.052 & 3.259 \\
		\bottomrule
	\end{tabular}	
\end{table}

\begin{itemize}
	\item Time it takes to run heuristics.
	\item Tables of comparisons.
	\item State that there are 20 types on average for real instances (no longer in table).
\end{itemize}

%---------------------------------

\section{Evolutionary Algorithm}
\label{sec:ea}
Throughout the EA we maintain two sets, $\mathcal{A}$ and $\mathcal{B}$, containing subsets of items that AHC has determined produce feasible or infeasible orderings, respectively. When an instance of the subproblem occurs, these sets are searched before calling AHC; hence AHC is executed at most once for each distinct subset of items.


\subsection{Crossover Operator}
\label{sub:xover}
(GGA) The strips of the second parent solution $\mathcal{S}_2$ are permuted, and two strips in $\mathcal{S}_2$ are selected randomly. These strips, along with all strips in between, are inserted into the offspring solution $\mathcal{S}$. The operator then adds to the offspring all strips from $\mathcal{S}_1$ that do not contain items already present in the offspring. Any items that are not in $\mathcal{S}$ are used to created a feasible partial solution $\mathcal{S}'$ using MFFD$^+$. Local search is then used on $\mathcal{S}$ and $\mathcal{S}'$ to produce a full offspring solution.

(GPX') Starting with the parent solution containing the fullest strip, the operator inserts this strip into the offspring $\mathcal{S}$, and strips containing items in $\mathcal{S}$ are removed from the other parent. GPX' repeats this process, alternating between parents, until $min (|\mathcal{S}_1|,|\mathcal{S}_2|) - 1$ strips have been added to the offspring.

GPN performs in the same manner as GPX', instead selecting strips containing the most items. This method aims to choose strips containing items that are harder to pack along with other items.


\subsection{Local Search}
\label{sub:localsearch}
Our local search method attempts to move items between two feasible partial solutions, $\mathcal{S}_X$ and $\mathcal{S}_Y$, in four stages: \begin{enumerate*}[label={(\arabic*)}]
	\item swapping a pair of items from a strip in $\mathcal{S}_X$ with a pair of items from a strip in $\mathcal{S}_Y$;
	\item swapping a pair of items from a strip in $\mathcal{S}_X$ with an individual item from a strip in $\mathcal{S}_Y$;
	\item swapping individual items from strips in $\mathcal{S}_X$ and $\mathcal{S}_Y$; and
	\item moving an item from a strip in $\mathcal{S}_Y$ to a strip in $\mathcal{S}_X$.
\end{enumerate*} 
During stages (1)--(3), the width of the item(s) from $\mathcal{S}_Y$ must exceed the width of the item(s) from $\mathcal{S}_X$. Once a swap or move has been perfomed, the procedure immediately moves on to the next stage. This method is repeated until all four stages have been executed in succession with no changes to $\mathcal{S}_X$ or $\mathcal{S}_Y$. Then, MFFD$^+$ is applied to any items remaining in $\mathcal{S}_Y$, generating a new feasible partial solution $\mathcal{S}_Y'$. The strips in $\mathcal{S}_Y'$, along with the strips in $\mathcal{S}_X$, are inserted into $\mathcal{S}$ to form a full feasible solution.

This method is based on the dominance criterion of Martello and Toth \cite{martello1990l}: if a strip $S_1$ \emph{dominates} a strip $S_2$, then a solution containing $S_1$ will have no more strips than a solution containing $S_2$. The local search procedure is in fact a local search for dominating strips. By moving larger items into $\mathcal{S}_X$, the ``fullness'' of the strips increase, whilst the number of items per strip is maintained or decreases, improving the quality of the strips in $\mathcal{S}_X$. Simultaneously, items moved into $\mathcal{S}_Y$ are smaller, and therefore easier to repack onto strips in $\mathcal{S}_X$ during stage (4). Variations of this method can be seen in \cite{falkenauer1996}, \cite{levine2004}, \cite{lewis2009}, \cite{lewis2017}, however the addition of the vicinal sum constraint results in fewer changes than seen in these previous implementations. By iterating the stages, we create numerous distinct subsets of items on the strips, generating more possibilities for feasible orderings of items.

\subsection{Mutation}
\label{sub:mutation}
Take candidate solution, permute strips, select a random number of strips from the solution to insert into partial solution $\mathcal{S}_X$, and the rest into $\mathcal{S}_Y$. Apply local search on $\mathcal{S}_X$ and $\mathcal{S}_Y$ to produce a single feasible solution.

\subsection{EA Process}
\label{sub:eaframework}
The algorithm begins by producing candidate solutions for the initial population, one using MFFD$^+$, the rest using MFFR$^+$ (that, is, the same method as MFFD$^+$ with the items in a random order). These solutions are mutated before being inserted into the population. An iteration of the EA involves selecting two parent solution, $\mathcal{S}_1$ and $\mathcal{S}_2$ from the population at random, applying a crossover operator to produce an offspring solution $\mathcal{S}$, then mutating this offspring before replacing the least fit of the two parents in the population (break ties randomly footnote). 

A fitness function is used to calculate a fitness value to determine the quality of a solution, as opposed to simply relying on the number of strips within the solution. The reason for this is twofold: firstly, given two candidate solutions of equal size, it is impossible to determine the better solution based on the number of strips alone. Secondly, we note that the quality of a solution not only depends on the number of strips used, but \emph{how} the items are packed onto the strip. Recall that strips that are ``fuller'' are preferrable over less filled strips, even if they contain more items. Thus, we consider a strip whose capacity is taken advantage of to be a ``better packed'' strip, reducing the amount of waste material. This may result in a strip in the solution that is nearly empty, which is beneficial as it allows further items to be packed, or the residual material could be used for other means. This type of packing is desirable over a packing of strips that are only half full, requiring more strips than necessary to pack all of the items. 

We therefore make use of the following function to calculate the fitness of a solution $\mathcal{S}$:

\begin{equation}
	f(\mathcal{S}) = \frac{\sum_{S \in \mathcal{S}} (A(S)/W)^2}{|\mathcal{S}|}
\end{equation}
\noindent where $A(S) = \sum_{i \in S} w_i$ is the total width of all items on a strip $S$. This function produces a fitness value between 0 and 1. The higher the fitness, the better the quality of the packing of items in the solution.


\begin{itemize}
	\item Only MFFD$^+$ used in EA
	\item Explain why GPX cannot be used, cite Lewis paper
	\item Preliminary check before calling AHC
	\item Set $\mathcal{F}$ is set of all subsets of items $\mathcal{I}' \subseteq \mathcal{I}$ that can produce a feasible ordering.
	\item A feasible solution or strip means that the solution/strip abides by all constraints.
	\item xOver:
	\item May have duplicate or missing items
	\item Note the differences between BPP and SCSPP, cannot simply remove individual items from strips, may cause the arrangement of remaining items to become infeasible (VSC not met between items)- hence why GPX cannot be used \cite{lewis2017}
	\item GGA $1 \leq i < j \leq |\mathcal{S}_Y|$ \textbf{and} cannot have $i = 1 \land j = |\mathcal{S}_Y|$ unlike in Rhyd paper - ensures that at least 2 strips from $\mathcal{S}_Y$ are in offspring, and prevents all strips from $\mathcal{S}_Y$ from being selected, as this would mean that all strips from $\mathcal{S}_X$ would be deleted from the offspring, and so offspring will not have strips from both parents. Ensures that offspring has strips from both parents.
	\item If missing items, repair procedure, then local search
	\item GGA - Permute strips of second parent solution, then choose two strips randomly, add all strips between two chosen strips (including chosen strips) and add to offspring. Then from first parent, only add strips to offspring containing items that are not in offspring. Repair procedure on missing items, if any.
	\item GPX' - Alternate between parent solutions, add fullest strip to offspring, delete strips from other parent containing items in offspring. Continue until $min(|\mathcal{S}_X|,|\mathcal{S}_Y|)-1$ strips in offspring. Repair procedure on missing items, if any. Initially, if both parents have fullest strip, break ties randomly.
	\item GPN - Operates in the same manner as GPX', except chose strip containing the most items. Initially, if both parents have strip containing same number of max items, choose the parent whose strip is the fullest. If equal for both strips, choose randomly.
	\item Once offspring produced, mutate and apply local search before replacing worst parent.
	\item Local Search:
	\item If stage four completed then reduce number of strips in $\mathcal{S}_Y$ by 1.
	\item MFFD$^+$ on $\mathcal{S}_Y$ to create $\mathcal{S}_Y'$, means that $|\mathcal{S}_Y'| \leq |\mathcal{S}_Y|$.
	\item Well-filled strips with larger items are always preferable over less-filled strips with smaller items \cite{levine2004}
	\item Initially permute the strips of both solutions
	\item This means local search takes longer, fewer swaps than seen in \cite{lewis2009}, \cite{lewis2017}, \cite{levine2004}, \cite{falkenauer1996} (check).
	\item Framework:
	\item Create 25 candidate solutions for initial population, one solution using MFFD$^+$, the others using MFFR$^+$ (items sorted in random order as opposed to decreasing order of widths), each solution is mutated before being inserted into the population.
	\item Each iteration of EA, two parent solutions $\mathcal{S}_1$ and $\mathcal{S}_2$ are chosen from the population at random, crossover operator used to create single offspring solution $\mathcal{S}$, which is then mutated before replacing the least fit parent solution in the population (breaking ties randomly).
	\item Fitness function $f(\mathcal{S}) = \frac{\sum_{S \in \mathcal{S}} (A(S)/W)^2}{|\mathcal{S}|}$ \cite{falkenauer1992}, $A(S) = \sum_{i \in S} w_i$ - ``fullness''/total width of all items on strip $S$, value between 0 and 1, closer to 1 = better packing, =1 means all strips are filled to capacity, perfect packing.
	\item Although two solutions $\mathcal{S}_1$ and $\mathcal{S}_2$ may contain the same number of strips/have the same size, fitness value identifies which solution contains a better packing of the items - distinguish between two solutions of the same size.
	\item Not only considering how many strips required to pack all items, but how those items are packed onto the strips (optimise how the strips are packed).
	\item Better packed strips means full capacity of strip is taken advantage of, reduce waste material on strips, plus nearly empty strips can be used to accommodate more items, or waste material can be reused.
	\item If the strips are packed well, fewer strips required, else if strips are not packed well, extra strips required to pack items that cannot be packed onto strips already being used.
	\item Take into account vicinal sum constraint - there may be two strips that are roughly equally filled, however even though it may seem that the items could be shuffled so that more are on one strip (thus a better packing), it may not be possible due to the constraint - not taken into account in other applications of this fitness value, however will still use this fitness value as our aim is to produce the best packing possible given the constraint.
\end{itemize}

\subsection{Experimental Results - EA}
\label{sub:expea}

\begin{table}[h!]
	\centering
	\caption{xOver comparisons}
	\begin{tabular}{cccccccccccc}\toprule
		& & & &\multicolumn{2}{c}{GGA} &\phantom{a}& \multicolumn{2}{c}{GPX'} &\phantom{a}& \multicolumn{2}{c}{GPN}\\
		\cmidrule{5-6} \cmidrule{8-9} \cmidrule{11-12}
		Instance & $W$ & $t$ && $|\mathcal{S}|$ & $\# t$ && $|\mathcal{S}|$ & $\# t$ && $|\mathcal{S}|$ & $\# t$ \\ \midrule	
		a,100 & 2500 & 23.323 && 23.483 & 931 && 23.357 & 977 && 23.372 & 966 \\
		a,100 & 5000 & 11.922 && EA151 & - && EA152 & - && EA153 & -\\
		\midrule
		a,500 & 2500 & 114.942 && 116.681 & 264 && 117.041 & 213 && 116.604 & 277 \\
		a,500 & 5000 & 57.722 && EA551 & - && EA552 & - && EA553 & -\\
		\midrule
		\midrule
		r,100 & 2500 & 23.473 && ER121 & - && ER122 & - && ER123 & -\\
		r,100 & 5000 & 11.981 && ER151 & - && ER152 & - && ER153 & -\\
		\midrule
		r,500 & 2500 & 115.239 && ER521 & - && ER522 & - && ER523 & -\\
		r,500 & 5000 & 57.865 && ER551 & - && ER552 & - && ER553 & -\\
		\bottomrule
	\end{tabular}	
	\label{table:EA}
\end{table}

\begin{itemize}
	\item Same instances used for heuristics used for EA
	\item Types of instances - artificial, real
	\item Problem instance generator will produce 1000 instances for four different sets, number of items = 100 and 500 and artificial and real instances, 4000 problem instances in total
	\item Each of these sets will then be run 6 times using different arguments - strip width = 2500 and 5000, and either GGA, GPX', or GPN
	\item Overall there will be 24 types of outputs from EA
	\item In EA output file to compare:
	\begin{itemize}
		\item Proportion of times feasPacking/infeasPacking sets used instead of AHC
		\item Number of strips in best solution found
		\item Number of iterations of EA within the given time limit
		\item Fitness value of the best solution found
		\item If best solution found is equivalent to the lowerbound
	\end{itemize}
	\item Keep track of best fitness/best solution/time at each iteration, if better solution found then write to file, produce graph
	\item At the end of each EA iteration, add all strips from offspring to feasPacking set to use in post optimisation phase
	\item number of solution in initial population = 25
	\item Number of items - 100, 500
	\item Time limit for EA - 5 minutes
	\item Width of strips - 2500, 5000
	\item Recombination operators - GGA, GPX', GPN
\end{itemize}


\section{Postoptimisation}
\label{sec:postopt}
\begin{itemize}
	\item Exact cover formulation, NP-hard, state the IP, describe DLX
	\item cite Knuth dancing steps
	\item Use strips in feasPacking for post opt
	\item Compare with EA output - is a better solution found, or a solution with the same number of strips but a better fitness value?
	\item Is the post opt phase able to find a solution equal to the lowerbound?
	\item Post opt will only ever find a solution equal to or better than the solution found in EA, never worse
	\item Execution time
	\item Set cover problem is optimisation problem, find min number of sets
	\item exact cover problem is decision problem, does a set exist
	\item however since we add every item on its own strip to feasPacking, we know that a set exists
	\item problem is to find minimum number of strips that covers all items and contains every item exactly once
	\item $A = (a_{ij})$ - $m$ x $n$ matrix
	\item $M = \{1, 2,..., m\}$ - rows of the matrix, each row $i \in M$ is a strip
	\item $N = \{1, 2,...,n\}$ - columns of the matrix, each column $j \in N$ is an item
	\item $(a_{ij}) = 1$ iff item $j$ is on strip $i$
	\item Say that row $i$ covers column $j$ if $a_{ij} = 1$
	\item Find the smallest number of strips $S \subseteq M$ that contains every item exactly once, i.e. union of strips $= \mathcal{I}$ and intersection $= \emptyset$
	\item Find minimum cardinality subset $S \subseteq M$ of rows such that each column $j \in N$ is covered by exactly one row $i \in S$
	\item Xpress mosel model
\end{itemize}
\[x_i =
\begin{cases} 
1 & \text{if } i \in S \\
0 & \text{otherwise} 
\end{cases}
\]

\begin{align*}
\text{minimise} &\sum_{i \in M} x_i \\
\text{subject to} &\sum_{i \in M} a_{ij} x_i = 1 \hspace{5mm} \forall j \in N \\
&x_i \in \{0,1\} \hspace{5mm} \forall i \in M
\end{align*}

\subsection{Experimental Results - Postoptimisation}
\label{sub:exppostopt}
\begin{itemize}
	\item
\end{itemize}

\section{Conclusion}
\label{sec:conclusion}
\begin{itemize}
	\item Could use selected packings rather than all packings
\end{itemize}

	

\cite{becker2010}, \cite{becker2015}, \cite{coffman1978}, \cite{coffman1984}, \cite{dosa2007} \cite{eilon1971} \cite{falkenauer1992} \cite{falkenauer1996}, \cite{garey1972}, \cite{garey1979}, \cite{garraffa2016}, \cite{gilmore1961}, \cite{gilmore1963}, \cite{goulimis2004}, \cite{haggkvist1977}, \cite{hawa2018}, \cite{hung1978}, \cite{johnson1973}, \cite{johnson1974fast}, \cite{johnson1974worst}, \cite{karp1972}, \cite{knuth2000}, \cite{korf2002}, \cite{levine2004}, \cite{lewis2009}, \cite{lewis2011}, \cite{lewis2017}, \cite{mahadev1994}, \cite{mahadev1995}, \cite{malaguti2008}, \cite{martello1990k}, \cite{martello1990l}, \cite{quiroz2015}

\bibliographystyle{elsarticle-num}
\bibliography{includes/bibliography}

\end{document}